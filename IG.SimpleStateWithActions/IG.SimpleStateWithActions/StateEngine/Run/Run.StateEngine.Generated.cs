//  <autogenerated>
//
//      This file was generated by T4 code generator 'StateEngineTemplate.tt'
//
//      Any changes made to this file manually will be lostnext time the file is regenerated.
//
//      As all classes are created as partial classes you can extend these classes by 
//      creating and adapting a matching partial class.
//
//</autogenerated>

using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using IG.SimpleStateWithActions.StateEngineShared;
using IG.SimpleStateWithActions.StateEngineShared.Exceptions;
using IG.SimpleStateWithActions.StateEngineShared.Interfaces;
using Newtonsoft.Json;
using IG.SimpleStateWithActions.Models;

namespace IG.SimpleStateWithActions.StateEngine
{
    public interface IRunState : IState<IRunState, RunStatesEnum>
    {
        IRunState Start();
        IRunState Finalize();
        IRunState Cancel();
        IRunState Fail();
        IRunState Reset();
      
    }

    public abstract class RunState : State<IRunState, RunStatesEnum>, IRunState
    {
        public virtual IRunState Start() => UndefinedTransition(nameof(Start));
        public virtual IRunState Finalize() => UndefinedTransition(nameof(Finalize));
        public virtual IRunState Cancel() => UndefinedTransition(nameof(Cancel));
        public virtual IRunState Fail() => UndefinedTransition(nameof(Fail));
        public virtual IRunState Reset() => UndefinedTransition(nameof(Reset));
        public override IRunState TechnicalError() => new RunStates.TechnicalError();
    }
     
    [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
    [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
    public enum RunStatesEnum 
    {
        Initial, InProgress, Done, Cancelled, Failed, TechnicalError
    }

    public class RunStates
    {
        public class Initial : RunState, IState<IRunState, RunStatesEnum>
        {
            public override RunStatesEnum Name => RunStatesEnum.Initial;
            public override IRunState Start() => new RunStates.InProgress();       
        }

        public class InProgress : RunState, IState<IRunState, RunStatesEnum>
        {
            public override RunStatesEnum Name => RunStatesEnum.InProgress;
            public override IRunState Finalize() => new RunStates.Done();       
            public override IRunState Cancel() => new RunStates.Cancelled();       
            public override IRunState Fail() => new RunStates.Failed();       
        }

        public class Done : RunState, IState<IRunState, RunStatesEnum>
        {
            public override RunStatesEnum Name => RunStatesEnum.Done;
            public override IRunState Reset() => new RunStates.Initial();       
        }

        public class Cancelled : RunState, IState<IRunState, RunStatesEnum>
        {
            public override RunStatesEnum Name => RunStatesEnum.Cancelled;
            public override IRunState Reset() => new RunStates.Initial();       
        }

        public class Failed : RunState, IState<IRunState, RunStatesEnum>
        {
            public override RunStatesEnum Name => RunStatesEnum.Failed;
            public override IRunState Reset() => new RunStates.Initial();       
        }

        public class TechnicalError : RunState, IState<IRunState, RunStatesEnum>
        {
            public override RunStatesEnum Name => RunStatesEnum.TechnicalError;
            public override IRunState Reset() => new RunStates.Initial();       
        }


    }

    public interface IRunStateEngineBase : IStateEngine<Run, IRunState, RunStatesEnum> { }

    /// <summary>
    /// 	RunStateController provides Actions that are to be executed on 
    /// 	state transitions. This allows modifications and interactions in
    /// 	and of the stated object when the state is about to change.
    /// </summary>
    public abstract class RunStateEngineBase : StateEngine<Run, IRunState, RunStatesEnum>, IRunStateEngineBase
    {

        public override List<Transition<Run, IRunState, RunStatesEnum>> Transitions 
            => new List<Transition<Run, IRunState, RunStatesEnum>>
            {
                new Transition<Run, IRunState, RunStatesEnum>(new RunStates.Initial(), state => state.Start(), StartRun, null,null),
                new Transition<Run, IRunState, RunStatesEnum>(new RunStates.InProgress(), state => state.Finalize(), FinalizeRun, state => state.Fail(),null),
                new Transition<Run, IRunState, RunStatesEnum>(new RunStates.InProgress(), state => state.Cancel(), null, null,null),
                new Transition<Run, IRunState, RunStatesEnum>(new RunStates.InProgress(), state => state.Fail(), null, null,null),
                new Transition<Run, IRunState, RunStatesEnum>(new RunStates.Done(), state => state.Reset(), null, null,null),
                new Transition<Run, IRunState, RunStatesEnum>(new RunStates.Cancelled(), state => state.Reset(), null, null,null),
                new Transition<Run, IRunState, RunStatesEnum>(new RunStates.Failed(), state => state.Reset(), null, null,null),
                new Transition<Run, IRunState, RunStatesEnum>(new RunStates.TechnicalError(), state => state.Reset(), StartCleanup, null,null),
            };

        // NOTE: if a constructor receiving specific dependencies is required, 
        //       defining the required constructor with all required dependencies 
        //       to handle the transitions, e. g. repositories, logger, etc.
        //       in the file RunStateEngine.Partial.cs file
        //
        //       implement the following methods as partial methods in that partial 
        //       class as well in order to satisfy the MethodGroup-Calls in the
        //       transition list above
        protected abstract Task<bool> StartRun(Run run);
        protected abstract Task<bool> FinalizeRun(Run run);
        protected abstract Task<bool> StartCleanup(Run run);
    }
} 

