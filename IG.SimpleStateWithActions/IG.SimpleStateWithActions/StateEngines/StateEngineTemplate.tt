<#@ template debug="false" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#
    var parentFolder = Host.ResolvePath("../");
    List<string> allEngineDescriptors = Directory.GetFiles(parentFolder, "*.StateEngine", SearchOption.AllDirectories).ToList();
    foreach (
        var file in
            allEngineDescriptors.Select(
                f => (
                    inFile: f, 
                        outDir: new FileInfo(f).DirectoryName))
                .ToList())
    {

        List<string> states = new List<string>();

        List<(string from, string transition, string to, string entityAction, string failTransition)> Transitions
            = new List<(string from, string transition, string to, string entityAction, string failTransition)>();

        string entity = "";
        string entityNamespace = "";

        string seNamespace = "";


        List<string> lines = File.ReadAllLines(file.inFile).Select(l => l.Replace(" ", "")).ToList();

        // read entity name
        var entityLine = lines.FirstOrDefault(l => l.StartsWith("Entity:"));
        if (!string.IsNullOrWhiteSpace(entityLine))
        {
            entity = entityLine.Split(':').Last().Trim();
        }

        // read states
        var statesLine = lines.FirstOrDefault(l => l.StartsWith("States:"));
        if (!string.IsNullOrWhiteSpace(statesLine))
        {
            states =
                statesLine.Split(':')[1].Split(',').Select(x => x.Trim()).Union(new[] {"Failed"}).Distinct()
                    .ToList();
        }

        // read transitions
        var transitionLines = lines.Where(l => l.StartsWith("T:"));
        Regex r =
            new Regex(
                @"(?<fromState>\w+)>(?<transition>\w+)>(?<toState>\w+)(\+(?<action>\w+))?(\-(?<failTransition>\w+))?");
        foreach (var transitionLine in transitionLines)
        {
            Match m = r.Match(transitionLine);
            if (m.Success)
            {
                Transitions.Add(
                    (
                        m.Groups["fromState"].Value, 
                            m.Groups["transition"].Value, 
                            m.Groups["toState"].Value,
                            m.Groups["action"].Value, 
                            m.Groups["failTransition"].Value
                        ));
            }
        }

        if (string.IsNullOrWhiteSpace(entity) || !states.Any() || !Transitions.Any())
        {
#>
// ERROR: StateEngine Description '<#= file.inFile #>' is invalid!         
<#
    continue;
        }

        var entityFile = Directory.GetFiles(parentFolder, $"{entity}.cs", SearchOption.AllDirectories);
        if (entityFile.Length != 1)
        {
#>
// ERROR: Entity-File '<#= $"{entity}.cs" #>' was not found!
<#
    continue;
        }
        else
        {
            entityNamespace = File.ReadAllLines(entityFile[0]).Where(l => l.StartsWith("namespace")).FirstOrDefault();
            if (string.IsNullOrWhiteSpace(entityNamespace))
            {
#>
// ERROR: Namespace Definition in Entity-File '<#= $"{entity}.cs" #>' was not found!
<#
    continue;
            }
            else
            {
                var seNamespaceParts = entityNamespace.Split('.');
                seNamespace = string.Join(".",
                    seNamespaceParts.Take(seNamespaceParts.Length - 1).Union(new[] {"StateEngines"}));
            }
        }

#>
//  <autogenerated>
//
//      This file was generated by T4 code generator 'StateEngineTamplate.tt'
//
//      Any changes made to this file manually will be lostnext time the file is regenerated.
//
//      As all classes are created as partial classes you can extend these classes by 
//      creating and adapting a matching partial class.
//
//</autogenerated>

using System;
using IG.SimpleStateWithActions.StateEngineShared;
using System.Collections.Generic;
using System.Linq.Expressions;
using IG.SimpleStateWithActions.StateEngineShared.Exceptions;
using <#= entityNamespace.Substring(9).Trim() #>;

<#= seNamespace #>
{
<#
        /// prepare values
        var transitionNames = Transitions
            .Where(x => x.transition != "Fail")
            .Select(t => t.transition).Distinct().ToList();

#>
    public interface I<#= entity #>State : IState<I<#= entity #>State>
    {
<#
        foreach (var t in transitionNames)
        {
#>
        I<#= entity #>State <#= t #> { get; }
<#
        }
#>
    }

    public abstract class <#= entity #>State : State<I<#= entity #>State>, I<#= entity #>State
    {
<#
        foreach (var t in transitionNames)
        {
#>
        public virtual I<#= entity #>State <#= t #> => Undefined("<#= t #>");
<#
        }
#>
        public override I<#= entity #>State Fail => new <#= entity #>States.Failed();
    }

    public class <#= entity #>States
    {
<#
        foreach (var s in states)
        {
#>
        public class <#= s #> : <#= entity #>State, IState<I<#= entity #>State>
        {
<#
    foreach (var t in Transitions.Where(t => t.from == s))
    {
#>
            public override I<#= entity #>State <#= t.transition #> => new <#= entity #>States.<#= t.to #>();       
<#
    }
#>
        }
<#
        }
#>
    }

    /// <summary>
    /// 	RunStateController provides Actions that are to be executed on 
    /// 	state transitions. This allows modifications and interactions in
    /// 	and of the stated object when the state is about to change.
    /// </summary>
    public partial class <#= entity #>StateEngine : StateEngine<<#= entity #>, I<#= entity #>State>
    {

        protected override List<
            (
                Type, 
                Expression<Func<I<#= entity #>State, I<#= entity #>State>> transition, 
                Action<<#= entity #>> action,
                Func<I<#= entity #>State, I<#= entity #>State> onFailedAction
            )> Transitions
            => new List<(Type, Expression<Func<I<#= entity #>State, I<#= entity #>State>> transition, Action<<#= entity #>> action,
                Func<I<#= entity #>State, I<#= entity #>State> onFailedAction)>
            {
<#
        foreach (var t in Transitions)
        {
#>
                (typeof(<#= entity #>States.<#= t.from #>), state => state.<#= t.transition #>, <#=
                    string.IsNullOrWhiteSpace(t.entityAction) ? "null" : t.entityAction #>, <#=
                    string.IsNullOrWhiteSpace(t.failTransition) ? "null" : $"state => state.{t.failTransition}" #>),
<#
        }
#>
            };

        // NOTE: if a constructor receiving specific dependencies is required, 
        //       defining the required constructor with all required dependencies 
        //       to handle the transitions, e. g. repositories, logger, etc.
        //       in the file <#= entity #>StateEngine.Partial.cs file
        //
        //       implement the following methods as partial methods in that partial 
        //       class as well in order to satisfy the MethodGroup-Calls in the
        //       transition list above
<#
        foreach (var t in Transitions.Where(t => !string.IsNullOrWhiteSpace(t.entityAction)))
        {
#>
        partial void <#= t.entityAction #>(<#= entity #> <#= entity.ToLower() #>);
<#
        }
#>
    }
} 
<#
        SaveFile(file.outDir, $"{entity}StateEngine.Generated.cs", this.GenerationEnvironment.ToString());
        this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
        string engineFile = Path.Combine(file.outDir, $"{entity}StateEngine.Partial.cs");
        if (File.Exists(engineFile)) continue;
#> 
//  <autogenerated>
//
//      This file was generated by T4 code generator 'StateEngineTamplate.tt'
//
//      Any changes made to this file manually will be PERSISTED.
//
//      This file will NOT be OVERWRITTEN at the next generation.
//      
//      Partial methods for new actions will have to be added manually.
//
//</autogenerated>
using System;
using IG.SimpleStateWithActions.StateEngineShared;
using System.Collections.Generic;
using System.Linq.Expressions;
using IG.SimpleStateWithActions.StateEngineShared.Exceptions;
using <#= entityNamespace.Substring(9).Trim() #>;

<#= seNamespace #>
{
    /// <summary>
    /// 	The RunStateController provides Actions that are to be executed on 
    /// 	state transitions. This allows modifications and interactions in
    /// 	and of the stated object when the state is about to change.
    /// </summary>
    public partial class <#= entity #>StateEngine
    {
        // NOTE: if a constructor receiving specific dependencies is required, create a partial
        //       class defining the according constructor with all dependencies that are required
        //       to handle the transitions, e. g. repositories, logger, etc.
        public <#= entity #>StateEngine(/* add dependencies here */)
        {
        }

        // NOTE: implement the following partial methods in order to process the entities
        //       in accordance to the corresponding transitions
<#
        foreach (var t in Transitions.Where(t => !string.IsNullOrWhiteSpace(t.entityAction)))
        {
#>
        partial void <#= t.entityAction #>(<#= entity #> <#= entity.ToLower() #>)
        {
            /* add logic here */
        }
<#
        }
#>
    }
}
<#
        SaveFile(file.outDir, engineFile, this.GenerationEnvironment.ToString());
        this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
    }
#> 
<#+
    public void SaveFile(string folder, string fileName, string content)
    {
        string engineFile = Path.Combine(folder, fileName);
        using(FileStream fs = new FileStream(Path.Combine(folder, engineFile.Trim()), FileMode.Create))
        using (StreamWriter str = new StreamWriter(fs))
        {
            str.WriteLine(content);
            str.Flush();
        }
    }
#>
